<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>登录注册优化 | 朝永的博客</title><meta name="author" content="朝永"><meta name="copyright" content="朝永"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="博客登录注册优化">
<meta property="og:type" content="article">
<meta property="og:title" content="登录注册优化">
<meta property="og:url" content="https://xiongchaoyong.github.io/posts/2d8be47d.html">
<meta property="og:site_name" content="朝永的博客">
<meta property="og:description" content="博客登录注册优化">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiongchaoyong.github.io/img/1.jpg">
<meta property="article:published_time" content="2025-10-20T06:45:00.000Z">
<meta property="article:modified_time" content="2025-10-23T09:28:16.470Z">
<meta property="article:author" content="朝永">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="博客">
<meta property="article:tag" content="思考">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiongchaoyong.github.io/img/1.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "登录注册优化",
  "url": "https://xiongchaoyong.github.io/posts/2d8be47d.html",
  "image": "https://xiongchaoyong.github.io/img/1.jpg",
  "datePublished": "2025-10-20T06:45:00.000Z",
  "dateModified": "2025-10-23T09:28:16.470Z",
  "author": [
    {
      "@type": "Person",
      "name": "朝永",
      "url": "https://xiongchaoyong.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xiongchaoyong.github.io/posts/2d8be47d.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '登录注册优化',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/qq%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-solid fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">朝永的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">登录注册优化</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-solid fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">登录注册优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-20T06:45:00.000Z" title="发表于 2025-10-20 14:45:00">2025-10-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-23T09:28:16.470Z" title="更新于 2025-10-23 17:28:16">2025-10-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/blog/">blog</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserLoginVO userLoginVO=UserLoginVO.builder().id(userInfo.getId()).token(token).build();</span><br></pre></td></tr></table></figure>

<h1 id="注册并发问题"><a href="#注册并发问题" class="headerlink" title="注册并发问题"></a>注册并发问题</h1><p>原来实现，存在并发问题，多个线程同时拿到相同的count</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(UserRegisterDTO userRegisterDto)</span> &#123;</span><br><span class="line">    <span class="comment">//设置账号</span></span><br><span class="line">    Long count=userMapper.getUserTotal();</span><br><span class="line">    String account=String.format(<span class="string">&quot;%06d&quot;</span>, count+<span class="number">1</span>);</span><br><span class="line">    userRegisterDto.setAccount(account);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userMapper.register(userRegisterDto);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;邮箱已经注册过了哦!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并发测试类(实际上需要注释掉register中的异常处理)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterConcurrentTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConcurrentRegister</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 并发线程数</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(threads);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threads);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalUsers</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">failedUsers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">UserRegisterDTO</span> <span class="variable">dto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserRegisterDTO</span>();</span><br><span class="line">                    <span class="comment">// 使用随机邮箱，避免数据库唯一约束冲突干扰测试账号字段</span></span><br><span class="line">                    dto.setEmail(UUID.randomUUID().toString() + <span class="string">&quot;@test.com&quot;</span>);</span><br><span class="line">                    dto.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">                    dto.setUsername(<span class="string">&quot;test&quot;</span> + finalI);</span><br><span class="line">                    userService.register(dto);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    failedUsers.getAndIncrement();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程完成</span></span><br><span class="line">        latch.await();</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;失败的注册用户数：&quot;</span> + failedUsers.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;成功率:&quot;</span>+ (totalUsers - failedUsers.get()) * <span class="number">1.0</span> / totalUsers);</span><br><span class="line">        System.out.println(<span class="string">&quot;并发注册测试完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>第一次测试数据</p>
<p>![image-20251022213644647](&#x2F;Users&#x2F;x&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20251022213644647.png)</p>
<blockquote>
<p>[!NOTE]</p>
<p>注意，这里的@Transactional其实没有什么用，这里是多线程提交，@Transactional只在单线程下生效，所以数据库中还是会有数据</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="加synchronized-阻塞"><a href="#加synchronized-阻塞" class="headerlink" title="加synchronized(阻塞)"></a>加synchronized(阻塞)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(UserRegisterDTO userRegisterDto)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="comment">//设置账号</span></span><br><span class="line">        Long count=userMapper.getUserTotal();</span><br><span class="line">        String account=String.format(<span class="string">&quot;%06d&quot;</span>, count+<span class="number">1</span>);</span><br><span class="line">        userRegisterDto.setAccount(account);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userMapper.register(userRegisterDto);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;邮箱已经注册过了哦!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>![image-20251022215416359](&#x2F;Users&#x2F;x&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20251022215416359.png)</p>
<h2 id="加ReentrantLock-阻塞"><a href="#加ReentrantLock-阻塞" class="headerlink" title="加ReentrantLock(阻塞)"></a>加ReentrantLock(阻塞)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(UserRegisterDTO userRegisterDto)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">        <span class="comment">//设置账号</span></span><br><span class="line">        Long count=userMapper.getUserTotal();</span><br><span class="line">        String account=String.format(<span class="string">&quot;%06d&quot;</span>, count+<span class="number">1</span>);</span><br><span class="line">        userRegisterDto.setAccount(account);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userMapper.register(userRegisterDto);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;邮箱已经注册过了哦!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>![image-20251022215712044](&#x2F;Users&#x2F;x&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20251022215712044.png)</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td>是否自动释放锁</td>
<td>是</td>
<td>否，需要手动释放</td>
</tr>
<tr>
<td>是否可中断&#x2F;超时</td>
<td>否</td>
<td>是，支持 tryLock &#x2F; lockInterruptibly</td>
</tr>
<tr>
<td>异常安全</td>
<td>自动释放</td>
<td>需写在 finally 中保证释放</td>
</tr>
<tr>
<td>灵活性</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<hr>
<p><strong>关键点</strong>：<code>synchronized</code> 是 <strong>JVM 层面管理锁</strong>，不需要手动释放；<code>ReentrantLock</code> 是 <strong>程序员手动管理锁</strong>，灵活但必须注意释放，否则容易死锁。</p>
<h2 id="redis分布式锁-非阻塞"><a href="#redis分布式锁-非阻塞" class="headerlink" title="redis分布式锁(非阻塞)"></a>redis分布式锁(非阻塞)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(UserRegisterDTO userRegisterDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(userRegisterDto.getEmail().isEmpty() || userRegisterDto.getPassword().isEmpty() || userRegisterDto.getUsername().isEmpty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;信息不完整!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RedisLock redisLock=<span class="keyword">new</span> <span class="title class_">RedisLock</span>(stringRedisTemplate,<span class="string">&quot;user:register&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!redisLock.tryLock(<span class="number">1L</span>))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;系统繁忙,请稍后重试!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断邮箱格式</span></span><br><span class="line">        <span class="keyword">if</span>(!ValidatorUtil.isValidEmail(userRegisterDto.getEmail()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;邮箱格式错误!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断邮箱是否已经注册</span></span><br><span class="line">        <span class="keyword">if</span>(userMapper.getByEmail(userRegisterDto.getEmail())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;该邮箱已经注册过了哦!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置账号</span></span><br><span class="line">        Long count=userMapper.getUserTotal();</span><br><span class="line">        String account=String.format(<span class="string">&quot;%06d&quot;</span>, count+<span class="number">1</span>);</span><br><span class="line">        userRegisterDto.setAccount(account);</span><br><span class="line">        userMapper.register(userRegisterDto);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;未知错误!&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(Long timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//请求线程id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate</span><br><span class="line">                .opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> b != <span class="literal">null</span> &amp;&amp; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程标识</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//获取锁中的标识（value）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">        <span class="comment">//判断标识是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (threadId.equals(id)) &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>![image-20251023001838702](&#x2F;Users&#x2F;x&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20251023001838702.png)</p>
<p><code>RedisLock.tryLock(10L)</code> 看起来像非阻塞模式：如果拿不到锁就直接返回 <code>false</code>。</p>
<p>高并发下，第一个线程抢到锁，其余线程几乎同时来尝试，<strong>拿不到就直接抛异常退出</strong>。</p>
<p>可能你的线程执行很快，几乎所有线程在第一个线程释放锁前就已经尝试抢锁，所以只看到一条成功。</p>
<p>还存在一个分布式锁的原子性问题</p>
<p>如下</p>
<p>if (threadId.equals(id)) {<br>            &#x2F;&#x2F;释放锁。    &#x2F;&#x2F;在这个地方当前锁过期，别的进程又拿到锁了，就又产生误删问题了<br>            stringRedisTemplate.delete(KEY_PREFIX + name);<br>        }</p>
<p>采用lua脚本实现原子操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            Thread.currentThread().getId()+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p>不可续期，不可重试，不可重入，主从一致性等等问题还需要自己实现</p>
<p>这就需要使用成熟的redis分布式锁解决方案了，那就是redisson</p>
<p>如果你不想用 starter，也可以直接引入 <code>redisson</code> 主包并手动创建 <code>RedissonClient</code>。starter 会自动注入 <code>RedissonClient</code> 为 Spring Bean</p>
<h2 id="redisson"><a href="#redisson" class="headerlink" title="redisson"></a>redisson</h2><h3 id="RLock-和阻塞性"><a href="#RLock-和阻塞性" class="headerlink" title="RLock 和阻塞性"></a>RLock 和阻塞性</h3><ul>
<li><strong>RLock</strong>：Redisson 提供的可重入锁（Reentrant Lock），本质上是一个分布式锁。</li>
<li><strong>lock()</strong>：<ul>
<li>是阻塞式的。</li>
<li>如果锁被其他线程&#x2F;进程占用，调用线程会一直等待，直到获取到锁。</li>
<li>支持 <strong>可重入</strong>：同一线程多次加锁不会阻塞自己。</li>
</ul>
</li>
<li><strong>tryLock()</strong>：<ul>
<li>默认非阻塞（立即返回 true&#x2F;false）。</li>
<li>可设置等待时间 <code>tryLock(waitTime, leaseTime, TimeUnit)</code>：<ul>
<li><code>waitTime</code>：最多等待时间，如果在这段时间内锁可用就获取锁，否则返回 false。</li>
<li><code>leaseTime</code>：锁的持有时间，到期自动释放。</li>
</ul>
</li>
<li>可以用它来避免长时间阻塞或死锁。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="RLock-相对于普通-Redis-分布式锁解决的问题"><a href="#RLock-相对于普通-Redis-分布式锁解决的问题" class="headerlink" title="RLock 相对于普通 Redis 分布式锁解决的问题"></a>RLock 相对于普通 Redis 分布式锁解决的问题</h3><table>
<thead>
<tr>
<th>问题</th>
<th>普通 Redis 分布式锁</th>
<th>RLock (Redisson)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>可重入</strong></td>
<td>不可重入，同一线程再次加锁会死锁</td>
<td>可重入，同一线程可多次加锁，每次加锁计数 +1，每次 unlock 计数 -1</td>
</tr>
<tr>
<td><strong>自动续期</strong></td>
<td>需要自己写 Lua 脚本或定时续期，否则锁可能超时释放</td>
<td>Redisson 内置锁自动续期机制（watchdog），避免锁在业务执行中被意外释放</td>
</tr>
<tr>
<td><strong>超时安全</strong></td>
<td>需要自己设置 TTL，复杂</td>
<td>可直接在 lock()&#x2F;tryLock() 指定持有时间，Redisson 会自动管理</td>
</tr>
<tr>
<td><strong>阻塞&#x2F;非阻塞</strong></td>
<td>只能模拟阻塞，需要轮询</td>
<td>lock() 阻塞、tryLock() 非阻塞并可设置超时</td>
</tr>
<tr>
<td><strong>原子性</strong></td>
<td>需要保证 set NX PX + Lua 原子操作</td>
<td>内置原子操作，自动保证加锁&#x2F;解锁原子性</td>
</tr>
</tbody></table>
<hr>
<p>所以你的总结：</p>
<ul>
<li><code>RLock</code> 是可重入锁 </li>
<li><code>lock()</code> 阻塞式 </li>
<li><code>tryLock()</code> 非阻塞式，可以自定义等待时间 </li>
<li>RLock 解决了 Redis 分布式锁下的 <strong>不可重入、超时续期、加锁原子性问题</strong></li>
</ul>
<h3 id="分布式锁的粒度"><a href="#分布式锁的粒度" class="headerlink" title="分布式锁的粒度"></a>分布式锁的粒度</h3><ul>
<li>你现在使用的是 <strong>全局锁</strong>（<code>LOCK_REGISTER</code>）：<ul>
<li>优点：绝对安全，避免重复注册和账号自增冲突</li>
<li>缺点：<strong>串行执行</strong>，高并发下注册性能受限</li>
</ul>
</li>
<li>可以考虑锁粒度更细，比如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redissonClient.getLock(&quot;user:register:&quot; + userRegisterDto.getEmail());</span><br></pre></td></tr></table></figure>

<p>这样不同邮箱可以并发注册，只防止同一邮箱重复注册。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(UserRegisterDTO userRegisterDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(userRegisterDto.getEmail().isEmpty() || userRegisterDto.getPassword().isEmpty() || userRegisterDto.getUsername().isEmpty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;信息不完整!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//判断邮箱格式</span></span><br><span class="line">        <span class="keyword">if</span>(!ValidatorUtil.isValidEmail(userRegisterDto.getEmail()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;邮箱格式错误!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//这里不能给每个邮箱单独上锁，因为还有账号的问题，但是要知道降低颗粒度这个点</span></span><br><span class="line">    <span class="comment">//RLock lock=redissonClient.getLock(RedisKeyConstants.LOCK_REGISTER+userRegisterDto.getEmail());</span></span><br><span class="line">      RLock lock=redissonClient.getLock(RedisKeyConstants.LOCK_REGISTER);</span><br><span class="line">    lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断邮箱是否已经注册</span></span><br><span class="line">        <span class="keyword">if</span>(userMapper.getByEmail(userRegisterDto.getEmail())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;该邮箱已经注册过了哦!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置账号</span></span><br><span class="line">        Long count=userMapper.getUserTotal();</span><br><span class="line">        String account=String.format(<span class="string">&quot;%06d&quot;</span>, count+<span class="number">1</span>);</span><br><span class="line">        userRegisterDto.setAccount(account);</span><br><span class="line">        userMapper.register(userRegisterDto);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (BaseException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e; <span class="comment">// 保留业务异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;未知错误!&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lock.isHeldByCurrentThread() &amp;&amp; lock.isLocked())&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>![image-20251023113030834](&#x2F;Users&#x2F;x&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20251023113030834.png)</p>
<h1 id="方法内部不能用private修饰"><a href="#方法内部不能用private修饰" class="headerlink" title="方法内部不能用private修饰"></a>方法内部不能用private修饰</h1><h3 id="1-变量的作用域不同"><a href="#1-变量的作用域不同" class="headerlink" title="1. 变量的作用域不同"></a>1. 变量的作用域不同</h3><p>在 Java 中，变量分为几类：</p>
<table>
<thead>
<tr>
<th>变量类型</th>
<th>声明位置</th>
<th>生命周期&#x2F;作用域</th>
<th>是否可以加访问修饰符</th>
</tr>
</thead>
<tbody><tr>
<td><strong>成员变量（Field）</strong></td>
<td>类体中，方法外</td>
<td>对象存在期间（实例变量）或类存在期间（静态变量）</td>
<td>可以（<code>private</code>、<code>protected</code>、<code>public</code>）</td>
</tr>
<tr>
<td><strong>局部变量（Local Variable）</strong></td>
<td>方法内部、构造器或代码块</td>
<td>方法执行期间，执行完就消失</td>
<td>不可以</td>
</tr>
<tr>
<td><strong>参数（Parameter）</strong></td>
<td>方法参数列表</td>
<td>方法执行期间</td>
<td>不可以</td>
</tr>
</tbody></table>
<p><strong>关键点</strong>：访问修饰符是用来控制 <strong>类外部对成员的访问权限</strong> 的，而局部变量只在方法内部可见，从本质上就是 <strong>私有的、方法私有的</strong>，不可能被外部访问。</p>
<hr>
<h3 id="2-访问修饰符的意义"><a href="#2-访问修饰符的意义" class="headerlink" title="2. 访问修饰符的意义"></a>2. 访问修饰符的意义</h3><p><code>private</code>、<code>protected</code>、<code>public</code> 是 <strong>面向对象封装性（Encapsulation）</strong> 的体现：</p>
<ul>
<li><strong>public</strong>：类外部都能访问</li>
<li><strong>protected</strong>：同包或子类能访问</li>
<li><strong>private</strong>：仅本类访问</li>
</ul>
<p><strong>局部变量</strong>只能在声明它的方法或代码块中使用，根本没有“类外部访问”的概念，所以 <strong>加访问修饰符没有意义</strong>，语法上也不允许。</p>
<hr>
<h3 id="3-JVM-内部的区别"><a href="#3-JVM-内部的区别" class="headerlink" title="3. JVM 内部的区别"></a>3. JVM 内部的区别</h3><ul>
<li>成员变量存储在 <strong>堆对象中</strong>（实例变量）或 <strong>方法区&#x2F;元空间</strong>（静态变量）</li>
<li>局部变量存储在 <strong>栈帧的局部变量表中</strong></li>
</ul>
<p>局部变量生命周期短、只存在于栈中，无法通过类访问，访问修饰符只影响类的外部访问，所以在 JVM 层面也是不适用的。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>局部变量不能使用访问修饰符的原因是：</p>
<ol>
<li>局部变量的作用域仅限方法内部，不存在类外部访问的可能。</li>
<li>访问修饰符的作用是控制 <strong>类外访问权限</strong>，局部变量天然就是私有的。</li>
<li>JVM 存储方式不同，局部变量只存在栈中，不属于类的一部分。</li>
</ol>
<p>![image-20251022232600267](&#x2F;Users&#x2F;x&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20251022232600267.png)</p>
<h1 id="锁的区别"><a href="#锁的区别" class="headerlink" title="锁的区别"></a>锁的区别</h1><p>好问题 —— 这是分布式系统设计里非常基础也很重要的一块。下面我把 <strong>基于 Redis 的分布式锁</strong> 跟 Java 里的 <strong><code>synchronized</code> &#x2F; <code>ReentrantLock</code></strong> 从多个维度逐项对比，并给出实践建议、常见坑和推荐实现方式。尽量把原理、行为、故障模式和实际工程取舍都讲清楚，便于你作决策。</p>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>synchronized</code> &#x2F; <code>ReentrantLock</code> 是 <strong>JVM 内的轻量同步原语</strong>：低延迟、可靠、适合单实例；而 <strong>Redis 分布式锁</strong> 是跨进程 &#x2F; 跨机器的协调手段：支持多实例互斥，但有网络延迟、故障边界更复杂，需要注意原子性、续期与误删等问题。哪一个用哪个场景取决于应用是否分布式、是否需要跨进程互斥、性能与可用性要求等。</p>
<hr>
<h3 id="1-作用域-可见性"><a href="#1-作用域-可见性" class="headerlink" title="1. 作用域 &amp; 可见性"></a>1. 作用域 &amp; 可见性</h3><ul>
<li><strong>synchronized &#x2F; ReentrantLock</strong><ul>
<li>只在单个 JVM（同一进程、同一类加载器）内生效。</li>
<li>不跨进程、不跨机器。</li>
</ul>
</li>
<li><strong>Redis 分布式锁</strong><ul>
<li>跨进程、跨主机，可用于多实例部署（微服务、多副本）之间的互斥。</li>
<li>需要网络通信，所有参与方访问同一个 Redis 实例或集群。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-实现-原理差异（关键）"><a href="#2-实现-原理差异（关键）" class="headerlink" title="2. 实现 &amp; 原理差异（关键）"></a>2. 实现 &amp; 原理差异（关键）</h3><ul>
<li><strong>synchronized</strong><ul>
<li>由 JVM&#x2F;HotSpot 在字节码层面实现（monitor enter&#x2F;exit），JVM 自动管理锁的获取与释放（异常也会释放）。</li>
</ul>
</li>
<li><strong>ReentrantLock</strong><ul>
<li>Java 库实现，提供更灵活 API（可重入、公平锁、<code>tryLock</code>、可中断锁等），需要手动 <code>unlock()</code>（通常在 <code>finally</code> 中）。</li>
</ul>
</li>
<li><strong>Redis 锁（自实现）</strong><ul>
<li>基本思路：<code>SET key value NX PX ttl</code> (atomic set-if-not-exist + expiry) 获取锁；释放时用 Lua 脚本判断 <code>value</code> 再 <code>DEL</code>，保证原子性。</li>
<li>底层依赖网络、Redis 单线程命令执行与 Lua 脚本原子性保证。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-原子性-正确性保障"><a href="#3-原子性-正确性保障" class="headerlink" title="3. 原子性 &amp; 正确性保障"></a>3. 原子性 &amp; 正确性保障</h3><ul>
<li><strong>JVM 锁</strong>：原子性由 JVM 保证（monitor&#x2F;Unsafe 等实现），没有网络不确定性。</li>
<li><strong>Redis 锁</strong>：必须保证两件事的原子性：<ul>
<li>加锁时必须是原子地 <code>SET NX EX</code>（不要把 <code>SETNX</code> 与 <code>EXPIRE</code> 分两步执行），否则容易死锁。</li>
<li>解锁时必须用 Lua 脚本 <code>if get(key)==value then del key end</code>，防止误删他人的锁（因为锁过期和重新被别人获得的竞态）。</li>
</ul>
</li>
<li><strong>实践</strong>：用 <code>SET key val NX PX ttl</code> + Lua 解锁；更复杂需用成熟库（Redisson）而不是自写轮子。</li>
</ul>
<hr>
<h3 id="4-可靠性与故障模式"><a href="#4-可靠性与故障模式" class="headerlink" title="4. 可靠性与故障模式"></a>4. 可靠性与故障模式</h3><ul>
<li><strong>JVM 锁</strong><ul>
<li>可靠（不涉网络），若线程死掉 JVM 挂掉则 JVM 层面处理。</li>
</ul>
</li>
<li><strong>Redis 锁</strong><ul>
<li>故障源更多：网络分区&#x2F;延迟、Redis 宕机、客户端崩溃、锁过期（lease）与业务超时、时钟漂移等。</li>
<li>常见问题：<ul>
<li><strong>误删别人的锁</strong>（如果不做 value 校验 + Lua）；</li>
<li><strong>锁过期导致两个客户端同时认为自己持有锁</strong>（业务执行 &gt; ttl 且没有续期）；</li>
<li><strong>单 Redis 实例故障</strong>：若单实例不可用，锁不可用；用 Redlock（多 Redis 节点）或 Zookeeper&#x2F;etcd 可提高可用性，但也有争议。</li>
</ul>
</li>
</ul>
</li>
<li><strong>注意</strong>：分布式锁无法像 JVM 锁那样简单可靠，需要综合考虑 CAP &#x2F;网络分区。</li>
</ul>
<hr>
<h3 id="5-reentrancy（可重入性）"><a href="#5-reentrancy（可重入性）" class="headerlink" title="5. reentrancy（可重入性）"></a>5. reentrancy（可重入性）</h3><ul>
<li><strong>synchronized &#x2F; ReentrantLock</strong>：天然可重入（同一线程可重复获得）。</li>
<li><strong>Redis 分布式锁</strong>：原生 <code>SET NX</code> 不支持可重入；库层（如 Redisson）通过把 value 关联到线程&#x2F;客户端并记录重入计数来实现可重入，但你用自写方案需要自己维护计数和续期逻辑。Redisson 为你封装好了。</li>
</ul>
<hr>
<h3 id="6-阻塞-中断-超时能力"><a href="#6-阻塞-中断-超时能力" class="headerlink" title="6. 阻塞&#x2F;中断&#x2F;超时能力"></a>6. 阻塞&#x2F;中断&#x2F;超时能力</h3><ul>
<li><strong>synchronized</strong>：阻塞（不能设置超时或中断等待），直到获得锁或发生异常。</li>
<li><strong>ReentrantLock</strong>：支持 <code>tryLock()</code>, <code>tryLock(timeout, unit)</code>, <code>lockInterruptibly()</code>（可中断、可设置超时）。</li>
<li><strong>Redis 锁</strong>：取决于实现：<ul>
<li>简单 <code>SET NX</code> 是非阻塞（拿不到就失败）；</li>
<li>可以实现阻塞等待 + 重试（睡眠+重试、或阻塞队列、或使用 Redisson 的 <code>tryLock(waitTime, leaseTime)</code>）；</li>
<li>中断性取决于客户端实现（Redisson 支持 wait + lease + 中断等特性）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-性能-延迟"><a href="#7-性能-延迟" class="headerlink" title="7. 性能 &amp; 延迟"></a>7. 性能 &amp; 延迟</h3><ul>
<li><strong>JVM 锁</strong>：本地内存同步，延迟极低（ns~μs），吞吐高。</li>
<li><strong>Redis 锁</strong>：网络调用（ms 级别），远比 JVM 锁慢；但在分布式场景是必要开销。若并发非常高且竞争频繁，会成为性能瓶颈（网络 RTT + Redis 处理）。</li>
</ul>
<hr>
<h3 id="8-可观测性-调试"><a href="#8-可观测性-调试" class="headerlink" title="8. 可观测性 &amp; 调试"></a>8. 可观测性 &amp; 调试</h3><ul>
<li><strong>JVM 锁</strong>：可通过线程 dump、jstack、JVM 工具跟踪死锁。</li>
<li><strong>Redis 锁</strong>：可以在 Redis 看 key 的存在情况、value、ttl；但并发复杂，调试需要日志和监控（看锁的创建&#x2F;删除、ttl、失败率）。Redisson 提供更丰富的监控和可视化手段。</li>
</ul>
<hr>
<h3 id="9-代码复杂度-使用风险"><a href="#9-代码复杂度-使用风险" class="headerlink" title="9. 代码复杂度 &amp; 使用风险"></a>9. 代码复杂度 &amp; 使用风险</h3><ul>
<li><strong>JVM 锁</strong>：简单、语言内建、错误率低（忘记 <code>unlock()</code> 在 ReentrantLock 下是常见错误，但容易发现）。</li>
<li><strong>Redis 分布式锁</strong>：实现细节多（原子性、唯一 value、Lua 解锁、续期、lease、看门狗、网络重试），如果自写容易出 bug。建议使用成熟库（Redisson、Curator for ZK）而不是自己拼接单条命令。</li>
</ul>
<hr>
<h3 id="10-一致性与语义差异"><a href="#10-一致性与语义差异" class="headerlink" title="10. 一致性与语义差异"></a>10. 一致性与语义差异</h3><ul>
<li><strong>JVM 锁</strong> 能保证严格的互斥语义（同一时刻只有一个线程执行临界区）。</li>
<li><strong>Redis 锁</strong> 在网络与 Redis 故障出现时，可能无法保证严格的互斥（例如锁过期后别的客户端拿到锁，此时旧客户端还在继续执行 -&gt; 导致并发执行）。必须用合理的 TTL &#x2F; 续期 &#x2F; 事务边界来降低风险。</li>
</ul>
<hr>
<h3 id="11-替代-更强的方案"><a href="#11-替代-更强的方案" class="headerlink" title="11. 替代&#x2F;更强的方案"></a>11. 替代&#x2F;更强的方案</h3><ul>
<li><strong>需要更强一致性</strong>（对安全要求极高）：使用 <strong>Zookeeper（Curator）</strong> 或 <strong>etcd</strong> 作为分布式协调，提供更强一致性语义。</li>
<li><strong>Redisson vs 自写</strong>：Redisson 提供看门狗续期、可重入、可靠解锁、便捷 API，生产推荐使用 Redisson 或基于 ZK 的 Curator。</li>
</ul>
<hr>
<h3 id="12-实战建议（Checklist）"><a href="#12-实战建议（Checklist）" class="headerlink" title="12. 实战建议（Checklist）"></a>12. 实战建议（Checklist）</h3><ol>
<li><strong>单机部署&#x2F;单实例</strong>：优先用 <code>synchronized</code> 或 <code>ReentrantLock</code>（简单、低延迟）。</li>
<li><strong>多实例部署需要跨进程互斥</strong>：用分布式锁；优先拿成熟实现（Redisson &#x2F; Zookeeper Curator）。</li>
<li><strong>若用 Redis 锁，必须做到</strong>：<ul>
<li>加锁用 <code>SET key value NX PX ttl</code>（原子），value 唯一（UUID包含机器ID+线程ID）；</li>
<li>解锁用 Lua 脚本判断 value 并原子删除；</li>
<li>考虑锁租约（lease）与续期（Redisson 看门狗）；</li>
<li>锁粒度尽可能细（按资源而不是全局）；</li>
<li>保留数据库唯一约束作为最后保险网。</li>
</ul>
</li>
<li><strong>避免业务执行时间超过锁 TTL</strong>：否则要么续期要么设计为分段操作。</li>
<li><strong>监控和退路</strong>：监控锁失败率、redis key ttl，做好监控预警与回滚策略。</li>
<li><strong>并发高且一致性强</strong>：考虑 ZK&#x2F;etcd（CP 系统）而非 Redis（AP 优化的场景下存在争议）。</li>
</ol>
<hr>
<h3 id="13-常见误区（快速列举）"><a href="#13-常见误区（快速列举）" class="headerlink" title="13. 常见误区（快速列举）"></a>13. 常见误区（快速列举）</h3><ul>
<li>误区 1：用 <code>SETNX</code> + <code>EXPIRE</code> 两步实现加锁（非原子）→ 会死锁。</li>
<li>误区 2：解锁直接 <code>DEL</code>（不校验 value）→ 误删别人锁。</li>
<li>误区 3：把 Redis 锁当成事务（分布式锁不是分布式事务）。</li>
<li>误区 4：不做唯一约束，完全靠锁 → 数据安全薄弱。</li>
</ul>
<hr>
<h3 id="14-小结（最终建议）"><a href="#14-小结（最终建议）" class="headerlink" title="14. 小结（最终建议）"></a>14. 小结（最终建议）</h3><ul>
<li>在 <strong>单体</strong>或<strong>仅需线程内同步</strong>场景用 <code>synchronized</code> &#x2F; <code>ReentrantLock</code>。</li>
<li>在 <strong>多实例</strong>或<strong>需要跨进程互斥</strong>场景用分布式锁，但：<strong>别自己从零实现复杂功能</strong>，优选 Redisson（或 ZK Curator），并严格按上面的安全模式（SET NX PX + Lua 或 Redisson 的实现）。</li>
<li>无论哪种方式，<strong>数据库唯一约束</strong>是最后的安全网，必须保留。</li>
</ul>
<h1 id="private-RedisKeyConstants"><a href="#private-RedisKeyConstants" class="headerlink" title="private RedisKeyConstants() {}"></a>private RedisKeyConstants() {}</h1><p>这是一个 <strong>Java 中常见的技巧</strong>，用于工具类或常量类。具体原因如下：</p>
<hr>
<h3 id="防止实例化"><a href="#防止实例化" class="headerlink" title="防止实例化"></a>防止实例化</h3><ul>
<li><code>RedisKeyConstants</code> 只是存放 <strong>常量</strong> 的类，没有任何实例方法或状态。</li>
<li>如果没有私有构造方法，其他地方可以写：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RedisKeyConstants constants = new RedisKeyConstants();</span><br></pre></td></tr></table></figure>

<p>虽然可以实例化，但其实没有意义，也可能误导别人以为这个类可以用来创建对象。</p>
<p>加上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private RedisKeyConstants() &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造方法被 <strong>private</strong> 修饰，外部无法访问</li>
<li>类就不能被实例化</li>
<li>明确告诉其他开发者：这是 <strong>工具类&#x2F;常量类</strong>，只用来访问静态成员</li>
</ul>
<hr>
<h3 id="防止被继承（可选）"><a href="#防止被继承（可选）" class="headerlink" title="防止被继承（可选）"></a>防止被继承（可选）</h3><p>如果你想进一步防止被继承，还可以加 <code>final</code> 修饰类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class RedisKeyConstants &#123;</span><br><span class="line">    private RedisKeyConstants() &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样：</p>
<ul>
<li>不能创建实例</li>
<li>不能被继承</li>
<li>完全用作 <strong>常量存储</strong> 或 <strong>静态工具方法类</strong></li>
</ul>
<hr>
<p>总结：<br>这个技巧的目的是 <strong>语义清晰 + 防止误用</strong>，不加也能用常量，但加上更规范，也符合 Java 开发习惯。</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h3 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h3><ul>
<li><strong>异常</strong>是程序运行过程中出现的错误情况。</li>
<li>Java 中异常是对象，继承自 <code>Throwable</code>。<ul>
<li><code>Error</code>：严重错误（JVM 相关），通常不处理。</li>
<li><code>Exception</code>：可处理的异常。<ul>
<li><code>Checked Exception</code>（受检异常）：编译器要求必须处理（如 <code>IOException</code>）。</li>
<li><code>Unchecked Exception</code>（运行时异常）：继承自 <code>RuntimeException</code>，可选择处理（如 <code>NullPointerException</code>、<code>IllegalArgumentException</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="异常的传播"><a href="#异常的传播" class="headerlink" title="异常的传播"></a>异常的传播</h3><ul>
<li><p><strong>throw</strong>：抛出异常，把异常传递给调用者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(user == null) throw new BaseException(&quot;用户不存在&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>throws</strong>：方法声明可能抛出的异常类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void readFile() throws IOException &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>catch</strong>：捕获异常，并在捕获块中处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    userService.register(dto);</span><br><span class="line">&#125; catch (BaseException e) &#123;</span><br><span class="line">    System.out.println(&quot;注册失败：&quot; + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>finally</strong>：无论是否抛出异常，都会执行（常用于资源释放）。</p>
</li>
</ul>
<h3 id="冒泡机制"><a href="#冒泡机制" class="headerlink" title="冒泡机制"></a>冒泡机制</h3><ul>
<li>异常如果没有被当前方法 <code>catch</code>，会一直向上冒泡到调用者，最终到 JVM。</li>
<li>如果到 JVM 还未处理：<ul>
<li><strong>线程终止</strong></li>
<li><strong>JVM 打印堆栈信息</strong></li>
<li><strong>主线程未捕获异常会终止整个程序</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="异常在多线程中的特点"><a href="#异常在多线程中的特点" class="headerlink" title="异常在多线程中的特点"></a>异常在多线程中的特点</h3><ul>
<li>每个线程有自己的异常处理链。</li>
<li><strong>子线程异常未捕获</strong>：<ul>
<li>不影响主线程继续执行</li>
<li>子线程终止，异常信息打印到控制台</li>
</ul>
</li>
<li><strong>主线程异常未捕获</strong>：<ul>
<li>整个程序终止</li>
</ul>
</li>
</ul>
<hr>
<h3 id="异常在你注册逻辑中的应用"><a href="#异常在你注册逻辑中的应用" class="headerlink" title="异常在你注册逻辑中的应用"></a>异常在你注册逻辑中的应用</h3><ul>
<li><p><strong>验证参数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(dto.getEmail().isEmpty()) throw new BaseException(&quot;邮箱不能为空&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>处理业务冲突</strong>（邮箱重复）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(userMapper.getByEmail(dto.getEmail()) != null) </span><br><span class="line">    throw new BaseException(&quot;邮箱已注册&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>捕获异常进行统计或日志</strong>（多线程测试中）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    userService.register(dto);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    failedUsers.getAndIncrement();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    latch.countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意</strong>：</p>
<ul>
<li><code>throw</code> 是向上抛异常，不会自己处理</li>
<li>捕获异常的对象是谁，就在该对象的 <code>catch</code> 块中处理</li>
<li>多线程中未捕获异常不会终止整个程序，但会终止该线程</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>异常处理是保证程序健壮性的关键。</li>
<li><strong>核心原则</strong>：<ol>
<li>能处理的尽量在业务逻辑或测试方法内捕获。</li>
<li>不能处理的可以 <code>throw</code> 给调用方。</li>
<li>多线程中异常需要特别注意，否则线程会悄悄终止。</li>
<li><code>finally</code> 块可以确保资源释放，即使异常发生也会执行。</li>
</ol>
</li>
</ul>
<h1 id="并发下的同步问题"><a href="#并发下的同步问题" class="headerlink" title="并发下的同步问题"></a>并发下的同步问题</h1><h3 id="一、核心思想：什么时候需要考虑？"><a href="#一、核心思想：什么时候需要考虑？" class="headerlink" title="一、核心思想：什么时候需要考虑？"></a>一、核心思想：什么时候需要考虑？</h3><p>一个最简单的判断原则是：<strong>当多个执行流（线程、进程、协程）可能同时访问（读或写）同一个共享资源，并且至少有一个执行流会修改这个资源时，就必须考虑同步问题。</strong></p>
<p>这里的“同时”不一定是物理时间上的绝对同一时刻，而是指在操作系统的调度下，一个执行流的操作可能被另一个执行流打断，从而导致操作序列交错。</p>
<p>如果不进行同步，就会导致 <strong>数据竞争</strong>，程序的执行结果将变得不可预测，依赖于线程调度的随机性，这是最令人头疼的Bug之一。</p>
<hr>
<h3 id="二、问题的根源：并发操作的三种“陷阱”"><a href="#二、问题的根源：并发操作的三种“陷阱”" class="headerlink" title="二、问题的根源：并发操作的三种“陷阱”"></a>二、问题的根源：并发操作的三种“陷阱”</h3><p>要理解为什么需要同步，我们先看并发操作会带来哪些具体问题。</p>
<h4 id="1-竞态条件"><a href="#1-竞态条件" class="headerlink" title="1. 竞态条件"></a>1. 竞态条件</h4><p><strong>定义：</strong> 程序的正确性依赖于线程&#x2F;进程的执行时序。<br><strong>经典例子：</strong> “检查后行动”</p>
<ul>
<li>场景：线程A检查银行账户余额（100元），发现足够支付90元。</li>
<li>中断： 在A执行扣款操作前，线程B被调度，从同一账户取走了80元（余额变为20元）。</li>
<li>错误： 线程A恢复执行，它基于之前检查的“100元”余额，执行扣款90元，导致账户变为-70元（或10元，取决于实现）。</li>
</ul>
<p>这里的问题在于，“检查余额”和“扣款”这两个操作本应是一个不可分割的原子操作，但在并发下被分开了。</p>
<h4 id="2-数据竞争"><a href="#2-数据竞争" class="headerlink" title="2. 数据竞争"></a>2. 数据竞争</h4><p><strong>定义：</strong> 多个线程未经同步，同时对一个共享变量进行写操作，或者一个读一个写。<br><strong>经典例子：</strong> 计数器递增 <code>counter++</code>。<br>这行代码在底层通常需要三个步骤：</p>
<ol>
<li>从内存读取 <code>counter</code> 的值到寄存器。</li>
<li>将寄存器中的值加1。</li>
<li>将新值写回内存。</li>
</ol>
<p>如果线程A和B同时执行：</p>
<ul>
<li>时刻1： A读取 <code>counter=5</code>。</li>
<li>时刻2： B读取 <code>counter=5</code>。</li>
<li>时刻3： A计算 <code>5+1=6</code>，写入内存，<code>counter=6</code>。</li>
<li>时刻4： B计算 <code>5+1=6</code>，写入内存，<code>counter=6</code>。</li>
</ul>
<p>最终结果应该是7，但因为数据竞争，结果变成了6。</p>
<h4 id="3-缓存不一致性"><a href="#3-缓存不一致性" class="headerlink" title="3. 缓存不一致性"></a>3. 缓存不一致性</h4><p>这是硬件层面的问题。现代CPU每个核心都有自己的缓存。当一个线程修改了其缓存中的共享变量时，其他线程的缓存中的副本并不会立即更新，导致它们看到的是过时的旧值。同步原语（如锁）在实现时，会触发底层的缓存一致性协议（如MESI），来保证所有线程看到的数据是一致的。</p>
<hr>
<h3 id="三、实际业务场景与解决方案"><a href="#三、实际业务场景与解决方案" class="headerlink" title="三、实际业务场景与解决方案"></a>三、实际业务场景与解决方案</h3><p>下面我们结合各种实际业务，看看这些问题如何体现，以及如何用同步机制解决。</p>
<h4 id="场景1：电商系统-库存扣减（竞态条件）"><a href="#场景1：电商系统-库存扣减（竞态条件）" class="headerlink" title="场景1：电商系统 - 库存扣减（竞态条件）"></a>场景1：电商系统 - 库存扣减（竞态条件）</h4><p><strong>业务逻辑：</strong> 用户下单购买商品，需要从库存中扣减对应数量。</p>
<p><strong>问题代码模拟：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 商品库存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户下单请求（可能被多个线程同时调用）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(<span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stock &gt;= quantity) &#123;</span><br><span class="line">        <span class="comment">// 模拟一些其他操作，比如检查用户信息等</span></span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        <span class="comment">// 在此期间，stock可能已经被其他线程修改</span></span><br><span class="line">        stock -= quantity; <span class="comment">// 问题发生在这里！</span></span><br><span class="line">        System.out.println(<span class="string">&quot;扣减成功，剩余库存：&quot;</span> + stock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个用户同时购买最后一件商品，很可能两个请求都通过了 <code>stock &gt;= 1</code> 的检查，导致库存被扣成 -1，即“超卖”。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><p><strong>加锁（最常用）：</strong> 将“检查”和“扣减”变成一个原子操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 锁对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(<span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123; <span class="comment">// 进入同步块，获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (stock &gt;= quantity) &#123;</span><br><span class="line">            stock -= quantity;</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减成功，剩余库存：&quot;</span> + stock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 退出同步块，释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数据库层面：</strong> 在高并发下，Java锁可能成为瓶颈。更常见的做法是在数据库更新时使用<strong>悲观锁</strong>（<code>SELECT ... FOR UPDATE</code>）或<strong>乐观锁</strong>（通过版本号 <code>version</code> 字段，<code>UPDATE table SET stock=stock-1, version=version+1 WHERE id=xxx AND version=old_version</code>）。</p>
</li>
</ol>
<h4 id="场景2：计数器-统计（数据竞争）"><a href="#场景2：计数器-统计（数据竞争）" class="headerlink" title="场景2：计数器 &amp; 统计（数据竞争）"></a>场景2：计数器 &amp; 统计（数据竞争）</h4><p><strong>业务逻辑：</strong> 统计网站访问量（PV）。</p>
<p><strong>问题代码模拟：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">pageViews</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>); <span class="comment">// 这是一个线程安全的类，我们用它来模拟问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个线程同时执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 即使使用AtomicInteger，错误的“先读后写”逻辑也会出问题</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> pageViews.get(); <span class="comment">// 步骤1：读</span></span><br><span class="line">    <span class="comment">// 线程可能在这里被切换</span></span><br><span class="line">    pageViews.set(current + <span class="number">1</span>); <span class="comment">// 步骤2：写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AtomicInteger</code> 本身的 <code>incrementAndGet()</code> 是原子的，但这里的 <code>get()</code> 和 <code>set()</code> 是分开的，依然存在数据竞争。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><p><strong>使用原子操作：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">pageViews</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">    pageViews.incrementAndGet(); <span class="comment">// 这是一个CPU级别的原子操作，无锁，性能高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用锁：</strong> 如果操作更复杂，不是简单的递增，则仍需锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">pageViews</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        pageViews++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="场景3：缓存系统-缓存失效与重建（缓存雪崩-击穿）"><a href="#场景3：缓存系统-缓存失效与重建（缓存雪崩-击穿）" class="headerlink" title="场景3：缓存系统 - 缓存失效与重建（缓存雪崩&#x2F;击穿）"></a>场景3：缓存系统 - 缓存失效与重建（缓存雪崩&#x2F;击穿）</h4><p><strong>业务逻辑：</strong> 当缓存中的数据过期时，需要从数据库加载最新数据。</p>
<p><strong>问题代码模拟：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 缓存失效，从数据库加载</span></span><br><span class="line">        data = loadDataFromDB(key);</span><br><span class="line">        cache.put(key, data); <span class="comment">// 简单的放入缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在超高并发下，如果某个热点key突然失效，大量线程会同时发现缓存为null，然后全部去访问数据库，瞬间的巨大流量可能导致数据库崩溃。这就是<strong>缓存击穿</strong>。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><p><strong>加锁重建：</strong> 只允许一个线程去数据库加载数据，其他线程等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">loadLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(loadLock) &#123; <span class="comment">// 注意，这里锁粒度较粗，可以优化为key级别的锁</span></span><br><span class="line">            <span class="comment">// 双重检查，因为进入同步块后，可能已经有其他线程加载好了</span></span><br><span class="line">            data = cache.get(key);</span><br><span class="line">            <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">                data = loadDataFromDB(key);</span><br><span class="line">                cache.put(key, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置不同的过期时间：</strong> 避免大量key在同一时间点失效。</p>
</li>
<li><p><strong>使用分布式锁：</strong> 在分布式环境下，需要使用Redis或ZooKeeper等实现分布式锁。</p>
</li>
</ol>
<h4 id="场景4：金融系统-账户转账（竞态条件）"><a href="#场景4：金融系统-账户转账（竞态条件）" class="headerlink" title="场景4：金融系统 - 账户转账（竞态条件）"></a>场景4：金融系统 - 账户转账（竞态条件）</h4><p><strong>业务逻辑：</strong> 从A账户向B账户转账100元。</p>
<p><strong>问题代码模拟：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account from, Account to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (from.getBalance() &gt;= amount) &#123;</span><br><span class="line">        <span class="comment">// 问题区域：两个账户的更新不是原子的</span></span><br><span class="line">        from.setBalance(from.getBalance() - amount);</span><br><span class="line">        to.setBalance(to.getBalance() + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在扣减A账户后，给B账户增加余额前，系统发生异常或线程被切换，会导致A的钱没了，B的钱也没到账，数据不一致。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><p><strong>数据库事务：</strong> 这是最根本的解决方案。将整个转账操作放在一个数据库事务中，利用数据库的ACID特性（原子性、一致性）来保证。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分布式事务：</strong> 如果A和B账户不在同一个数据库，则需要使用更复杂的分布式事务方案（如Seata）或最终一致性方案（如通过消息队列）。</p>
</li>
</ol>
<h4 id="场景5：单例模式（竞态条件）"><a href="#场景5：单例模式（竞态条件）" class="headerlink" title="场景5：单例模式（竞态条件）"></a>场景5：单例模式（竞态条件）</h4><p><strong>业务逻辑：</strong> 确保一个类只有一个实例。</p>
<p><strong>问题代码模拟（懒汉式）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第一次检查</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 问题行：多个线程可能同时进入这里</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：</strong></p>
<ol>
<li><p><strong>双重检查锁定：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// volatile 防止指令重排，保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第一次检查，避免不必要的同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第二次检查，在锁的保护下</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态内部类：</strong> 更优雅的方案，利用类加载机制保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="四、常用的同步工具-机制"><a href="#四、常用的同步工具-机制" class="headerlink" title="四、常用的同步工具&#x2F;机制"></a>四、常用的同步工具&#x2F;机制</h3><ol>
<li><strong>互斥锁：</strong> 如Java的 <code>synchronized</code>，<code>ReentrantLock</code>。保证同一时间只有一个线程能进入临界区。<strong>悲观锁</strong>思想的体现。</li>
<li><strong>原子变量：</strong> 如 <code>java.util.concurrent.atomic</code> 包下的 <code>AtomicInteger</code> 等。通过CPU的CAS指令实现无锁线程安全，适用于计数器等场景。</li>
<li><strong>信号量：</strong> 如 <code>Semaphore</code>。用来控制同时访问特定资源的线程数量，例如数据库连接池。</li>
<li><strong>并发容器：</strong> 如 <code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code>。这些容器在内部已经做好了同步，可以直接在并发环境下使用。</li>
<li>** volatile 关键字：** 保证变量的可见性（一个线程修改后，新值立即对其他线程可见），并禁止指令重排序。但它不保证原子性。</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">业务场景</th>
<th align="left">核心问题</th>
<th align="left">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>库存扣减</strong></td>
<td align="left">竞态条件（超卖）</td>
<td align="left"><strong>加锁</strong>（Java锁、数据库悲观&#x2F;乐观锁）</td>
</tr>
<tr>
<td align="left"><strong>计数器统计</strong></td>
<td align="left">数据竞争</td>
<td align="left"><strong>原子变量</strong>（<code>incrementAndGet</code>）或<strong>锁</strong></td>
</tr>
<tr>
<td align="left"><strong>缓存重建</strong></td>
<td align="left">竞态条件（缓存击穿）</td>
<td align="left"><strong>锁</strong>（双重检查锁）、设置随机过期时间</td>
</tr>
<tr>
<td align="left"><strong>账户转账</strong></td>
<td align="left">竞态条件（数据不一致）</td>
<td align="left"><strong>数据库事务</strong>、分布式事务</td>
</tr>
<tr>
<td align="left"><strong>单例模式</strong></td>
<td align="left">竞态条件（多实例）</td>
<td align="left"><strong>双重检查锁 + volatile</strong>、<strong>静态内部类</strong></td>
</tr>
</tbody></table>
<p><strong>最后的忠告：</strong></p>
<ul>
<li><strong>最小化同步范围：</strong> 只锁住必要的代码块，减少锁的持有时间，以提高性能。</li>
<li><strong>避免死锁：</strong> 确保获取锁的顺序是一致的。</li>
<li><strong>优先使用高级工具：</strong> 在可能的情况下，优先使用 <code>java.util.concurrent</code> 包下的并发容器和工具类，而不是自己从头实现同步。</li>
<li><strong>无锁编程：</strong> 在性能要求极高的场景，可以考虑CAS等无锁编程，但复杂度较高。</li>
</ul>
<p>并发同步是构建稳健、高并发系统的基石，理解其原理并正确应用，是每一位后端开发者的必备技能。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a><strong>CAS</strong></h1><h3 id="一、CAS-是什么？"><a href="#一、CAS-是什么？" class="headerlink" title="一、CAS 是什么？"></a>一、CAS 是什么？</h3><p><strong>CAS</strong> 的全称是 <strong>Compare-And-Swap</strong>，中文译为 <strong>“比较并交换”</strong> 或 <strong>“比较并替换”</strong>。</p>
<p>它是一种用于实现并发算法的<strong>原子操作</strong>。你可以把它理解为一个由CPU硬件提供支持的、不可中断的“机器指令”。</p>
<h3 id="二、CAS-的核心思想"><a href="#二、CAS-的核心思想" class="headerlink" title="二、CAS 的核心思想"></a>二、CAS 的核心思想</h3><p>CAS 操作包含三个操作数：</p>
<ol>
<li><strong>内存位置（V）</strong></li>
<li><strong>期望的原值（A）</strong></li>
<li><strong>新值（B）</strong></li>
</ol>
<p>它的工作流程可以用以下伪代码来理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function CAS(V, A, B) is</span><br><span class="line">    if V == A       // 比较：当前内存值V是否等于期望的原值A？</span><br><span class="line">        then V ← B  // 交换：如果相等，则将内存值V更新为新值B</span><br><span class="line">        return true // 成功</span><br><span class="line">    else</span><br><span class="line">        return false // 失败</span><br></pre></td></tr></table></figure>

<p><strong>通俗地讲，CAS 的操作就是：</strong></p>
<blockquote>
<p>“我认为内存位置 V 的值应该是 A。如果是，那么把它更新成 B；如果不是（说明在我之后已经有其他线程修改了它），那么什么都不做，然后告诉我失败。”</p>
</blockquote>
<p><strong>整个“比较”和“交换”这两个步骤是一个不可分割的原子操作</strong>。这意味着在执行过程中，不会有其他线程能够打断它并修改 V 的值。</p>
<hr>
<h3 id="三、一个生动的例子：乐观的版本控制"><a href="#三、一个生动的例子：乐观的版本控制" class="headerlink" title="三、一个生动的例子：乐观的版本控制"></a>三、一个生动的例子：乐观的版本控制</h3><p>想象一下，你和你的同事在共同编辑一份在线文档（比如Google Docs）。</p>
<ul>
<li><p><strong>不加锁的方式（CAS思想）：</strong></p>
<ol>
<li>你打开文档，看到内容是 “Version 1”。（<strong>读取原值 A &#x3D; “Version 1”</strong>）</li>
<li>你基于 “Version 1” 进行修改，准备提交 “Version 2”。（<strong>计算新值 B &#x3D; “Version 2”</strong>）</li>
<li>在你点击“保存”时，系统会检查：<strong>现在服务器上的文档还是 “Version 1” 吗？</strong><ul>
<li><strong>如果是</strong>：说明在你编辑期间没有别人改动，系统成功保存你的 “Version 2”。（<strong>CAS 成功</strong>）</li>
<li><strong>如果不是</strong>：比如已经变成了 “Version 1.5”（<strong>当前内存值 V &#x3D; “Version 1.5”</strong>），说明有同事抢先提交了修改。系统会拒绝你的保存，并让你基于最新的 “Version 1.5” 重新进行修改。（<strong>CAS 失败</strong>）</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>加锁的方式（悲观锁）：</strong></p>
<ol>
<li>你在编辑前，先“锁定”这份文档，告诉所有人“我正在编辑，你们别动”。</li>
<li>你开始编辑。</li>
<li>你编辑完成后保存，然后“释放锁”。</li>
<li>在这个过程中，你的同事只能等待。</li>
</ol>
</li>
</ul>
<p><strong>CAS 体现的是一种“乐观锁”的思想</strong>：它假设大多数情况下不会发生冲突，所以先放心去做，只在最后提交时检查一下是否有冲突。如果有冲突，就重试。</p>
<hr>
<h3 id="四、CAS-在-Java-中的实现"><a href="#四、CAS-在-Java-中的实现" class="headerlink" title="四、CAS 在 Java 中的实现"></a>四、CAS 在 Java 中的实现</h3><p>在 Java 中，CAS 操作不是直接通过代码实现的，而是通过本地方法，最终调用 CPU 的指令（如 x86 架构下的 <code>cmpxchg</code> 指令）。</p>
<p>我们最常接触到的是在 <code>java.util.concurrent.atomic</code> 包下的原子类，例如 <code>AtomicInteger</code>。</p>
<h4 id="以-AtomicInteger-的-incrementAndGet-为例："><a href="#以-AtomicInteger-的-incrementAndGet-为例：" class="headerlink" title="以 AtomicInteger 的 incrementAndGet() 为例："></a>以 <code>AtomicInteger</code> 的 <code>incrementAndGet()</code> 为例：</h4><p>它的内部实现就使用了 CAS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个典型的自旋循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 循环，直到成功为止</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get(); <span class="comment">// 步骤1：获取当前值（期望的原值 A）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>; <span class="comment">// 步骤2：计算出新值 B</span></span><br><span class="line">        <span class="comment">// 步骤3：调用CAS，比较并交换</span></span><br><span class="line">        <span class="comment">// 如果当前值还是 current，就更新为 next</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next; <span class="comment">// 更新成功，返回新值</span></span><br><span class="line">        <span class="comment">// 如果CAS失败，说明当前值已经被其他线程修改，循环重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个过程就是经典的 “CAS自旋”：</strong></p>
<ol>
<li>获取当前值。</li>
<li>计算目标值。</li>
<li>尝试用 CAS 更新。</li>
<li>如果更新失败（因为值被其他线程改了），回到第1步，<strong>循环重试</strong>。</li>
</ol>
<hr>
<h3 id="五、CAS-的优缺点"><a href="#五、CAS-的优缺点" class="headerlink" title="五、CAS 的优缺点"></a>五、CAS 的优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li><strong>高性能</strong>：相对于传统的互斥锁（如 <code>synchronized</code>），它在竞争不激烈的情况下性能更高。因为它避免了线程的挂起和上下文切换（这些都是很重的操作），而是通过CPU指令在用户态完成冲突检测。</li>
<li><strong>无锁</strong>：它是一种“无锁”编程技术，可以避免死锁等复杂问题。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li><strong>ABA 问题</strong>：<ul>
<li><strong>描述</strong>：一个线程读到内存值是 A，随后检查它还是 A，于是就认为它没有被修改过。但实际情况可能是：另一个线程把它改成了 B，然后又改回了 A。</li>
<li><strong>例子</strong>：你看到一瓶可乐是满的（A），然后你去忙别的了。期间你的朋友喝掉了它（A -&gt; B），然后又给你重新倒满（B -&gt; A）。你回来后一看，还是满的（A），以为没人动过，就开心地喝了。虽然结果看起来一样，但过程已经发生了变化。</li>
<li><strong>解决方案</strong>：给值加上一个版本号（Stamp）。Atomic 包中提供了 <code>AtomicStampedReference</code> 来解决这个问题。</li>
</ul>
</li>
<li><strong>循环时间长开销大</strong>：<ul>
<li>如果CAS操作长时间不成功（竞争非常激烈），CPU会一直进行自旋循环，这会消耗大量的CPU资源。</li>
<li>在这种情况下，使用传统的锁可能效率更高，因为竞争失败的线程会挂起，让出CPU。</li>
</ul>
</li>
<li><strong>只能保证一个共享变量的原子操作</strong>：<ul>
<li>CAS 操作本身是针对一个内存地址的。如果你要对多个共享变量同时进行原子操作，CAS 无法直接做到。不过你可以将它们合并成一个对象，然后用 <code>AtomicReference</code> 来包装这个对象。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="六、CAS-的实际应用"><a href="#六、CAS-的实际应用" class="headerlink" title="六、CAS 的实际应用"></a>六、CAS 的实际应用</h3><ol>
<li><strong>Java 并发包（JUC）</strong>：<code>AtomicInteger</code>, <code>AtomicLong</code>, <code>AtomicReference</code> 等原子类的实现基石。</li>
<li><strong>并发容器</strong>：<code>ConcurrentHashMap</code> 在 JDK 8 后的实现中，大量使用了 CAS 来优化性能，比如在 put 操作时初始化数组桶（<code>initTable</code>）和向链表头插入节点。</li>
<li><strong>无锁数据结构</strong>：基于 CAS 可以实现高效的无锁队列、无锁栈等。</li>
<li><strong>数据库和分布式系统</strong>：乐观锁机制，例如上面提到的通过版本号 <code>version</code> 字段实现更新。</li>
</ol>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><strong>CAS 是一种“乐观”的、硬件实现的原子操作，它通过“比较-交换”的逻辑来判断在操作过程中是否有其他干扰，无干扰则成功，有干扰则失败并通常伴随重试。它是现代无锁并发编程的核心，在高并发场景下能提供比传统锁更好的性能，但也需要警惕 ABA 问题和CPU空转的开销。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xiongchaoyong.github.io">朝永</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xiongchaoyong.github.io/posts/2d8be47d.html">https://xiongchaoyong.github.io/posts/2d8be47d.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://xiongchaoyong.github.io" target="_blank">朝永的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a><a class="post-meta__tags" href="/tags/%E6%80%9D%E8%80%83/">思考</a><a class="post-meta__tags" href="/tags/%E5%8D%9A%E5%AE%A2/">博客</a></div><div class="post-share"><div class="social-share" data-image="/img/1.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/8f052d86.html" title="github登录"><img class="cover" src="/img/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">github登录</div></div><div class="info-2"><div class="info-item-1">回掉页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt;  &lt;div style=&quot;text-align: center; margin-top: 50px&quot;&gt;    &lt;p&gt;正在处理 GitHub 登录，请稍候...&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &quot;vue&quot;;import &#123; githubLogin &#125; from &quot;@/api/uuser&quot;;import &#123; useUserStore &#125; from &quot;@/stores/userStore&quot;;import &#123; g...</div></div></div></a><a class="pagination-related" href="/posts/eae30b66.html" title="毛概客观题"><img class="cover" src="/img/2.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">毛概客观题</div></div><div class="info-2"><div class="info-item-1">一、毛泽东思想1. 形成发展历程   时期 历史阶段 理论成果 特点    萌芽时期 国民革命时期（1924-1927） 新民主主义革命思想开始萌芽 结合中国国情探索革命道路   初步形成 土地革命战争时期（1927-1937） 《中国的红色政权为什么能够存在》《星星之火，可以燎原》等 提出农村包围城市、武装夺取政权   成熟时期 抗日战争时期（1937-1945） 《实践论》《矛盾论》《新民主主义论》 思想体系基本成熟   继续发展 解放战争时期及建国初期 新民主主义革命理论系统完成，提出人民民主专政理论 指导中国革命取得胜利    2. 毛泽东思想的科学体系主要内容包括：  新民主主义革命理论（总路线、革命对象、动力、领导、前途） 社会主义革命和建设理论 革命军队建设和军事战略理论 政策与策略理论 思想政治工作和文化工作理论 党的建设理论   3. 毛泽东思想的地位 马克思列宁主义在中国的运用和发展 被实践证明的正确理论原则和经验总结 中国共产党集体智慧的结晶 党和国家长期指导思想   4. 毛泽东思想的活的灵魂（三大基本方面） 实事求是：从实际出发，理论联系实际 群众路线：...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/8f052d86.html" title="github登录"><img class="cover" src="/img/1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-20</div><div class="info-item-2">github登录</div></div><div class="info-2"><div class="info-item-1">回掉页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt;  &lt;div style=&quot;text-align: center; margin-top: 50px&quot;&gt;    &lt;p&gt;正在处理 GitHub 登录，请稍候...&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted &#125; from &quot;vue&quot;;import &#123; githubLogin &#125; from &quot;@/api/uuser&quot;;import &#123; useUserStore &#125; from &quot;@/stores/userStore&quot;;import &#123; g...</div></div></div></a><a class="pagination-related" href="/posts/7b25d017.html" title="redis"><img class="cover" src="/img/5.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-20</div><div class="info-item-2">redis</div></div><div class="info-2"><div class="info-item-1"> Redis 的“单线程”是什么意思  好的，这是一个非常经典且重要的问题。我们来详细解释一下 Redis 的“单线程”是什么意思，以及它带来的好处和需要注意的地方。 Redis 单线程是什么意思？首先，需要明确一个关键点：我们通常所说的“Redis 是单线程”，指的是其核心的网络 I&#x2F;O 和键值对读写是由一个线程来完成的。 这并不意味着 Redis 在整个软件层面都是单线程的。现代版本的 Redis 在后台会使用一些额外的线程来处理其他任务，例如：  持久化：在生成 RDB 快照或重写 AOF 日志时，会 fork 出子进程来完成（注意，是进程，不是线程）。在 AOF 的 fsync 等某些环节也可能使用线程。 异步删除：当你使用 UNLINK 命令删除一个大键，或者使用 FLUSHDB ASYNC &#x2F; FLUSHALL ASYNC 命令时，实际的内存回收会交给后台线程处理，以避免阻塞主线程。 其他模块任务：一些复杂的模块可能会使用自己的线程。  所以，最准确的理解是：Redis 处理客户端请求的核心模块是单线程的。 这个主线程负责处理所有命令的接收、解析、...</div></div></div></a><a class="pagination-related" href="/posts/ebf53b55.html" title="秒杀"><img class="cover" src="/img/3.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-20</div><div class="info-item-2">秒杀</div></div><div class="info-2"><div class="info-item-1">3、优惠卷秒杀3.1 -全局唯一ID每个店铺都可以发布优惠券：  当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：  id的规律性太明显 受单表数据量的限制  场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。 场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。 全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：      UUID	MySQL8.0以后，UUID可以自增且减少了存储空间 Redis自增 snowflake算法     依赖于系统时间，需要机器间的时间一致 数据库自增     专门弄一个数据库表用于自增id的获取，类似Redis，但是性能差于redis   为了增加ID的安全性，我们可以不直接使用...</div></div></div></a><a class="pagination-related" href="/posts/b8e1dc7c.html" title="缓存策略"><img class="cover" src="/img/1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-20</div><div class="info-item-2">缓存策略</div></div><div class="info-2"><div class="info-item-1">2、商户查询缓存2.1 什么是缓存?前言:什么是缓存?  就像自行车,越野车的避震器 举个例子:越野车,山地自行车,都拥有”避震器”,防止车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的损害,像个弹簧一样; 同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪; 这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术; 缓存(Cache),就是数据交换的缓冲区,俗称的缓存就是缓冲区内的数据,一般从数据库中获取,存储于本地代码(例如: 12345例1:Static final ConcurrentHashMap&lt;K,V&gt; map = new ConcurrentHashMap&lt;&gt;(); 本地用于高并发例2:static final Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存例3:Static final Map&lt;K,V&gt; map =  new Hash...</div></div></div></a><a class="pagination-related" href="/posts/bb426678.html" title="短信登录"><img class="cover" src="/img/2.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-20</div><div class="info-item-2">短信登录</div></div><div class="info-2"><div class="info-item-1">1、短信登录1.1、导入黑马点评项目1.1.1 、导入SQL 1.1.2、有关当前模型手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。 在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会...</div></div></div></a><a class="pagination-related" href="/posts/faa6226c.html" title="达人探店"><img class="cover" src="/img/1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-20</div><div class="info-item-2">达人探店</div></div><div class="info-2"><div class="info-item-1">8、达人探店8.1、达人探店-发布探店笔记发布探店笔记 探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：tb_blog：探店笔记表，包含笔记中的标题、文字、图片等tb_blog_comments：其他用户对探店笔记的评价 具体发布流程  上传接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Slf4j@RestController@RequestMapping(&quot;upload&quot;)public class UploadController &#123;    @PostMapping(&quot;blog&quot;)    public Result uploadImage(@RequestParam(&quot;file&quot;) MultipartFile image) &#123;        try &#123;            // 获取原始文件名称            String ori...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/qq%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">朝永</div><div class="author-info-description">一个记录代码与思考的地方</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">注册并发问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.0.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0synchronized-%E9%98%BB%E5%A1%9E"><span class="toc-number">1.1.</span> <span class="toc-text">加synchronized(阻塞)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0ReentrantLock-%E9%98%BB%E5%A1%9E"><span class="toc-number">1.2.</span> <span class="toc-text">加ReentrantLock(阻塞)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">1.3.</span> <span class="toc-text">redis分布式锁(非阻塞)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redisson"><span class="toc-number">1.4.</span> <span class="toc-text">redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RLock-%E5%92%8C%E9%98%BB%E5%A1%9E%E6%80%A7"><span class="toc-number">1.4.1.</span> <span class="toc-text">RLock 和阻塞性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RLock-%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%99%AE%E9%80%9A-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.2.</span> <span class="toc-text">RLock 相对于普通 Redis 分布式锁解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="toc-number">1.4.3.</span> <span class="toc-text">分布式锁的粒度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E4%B8%8D%E8%83%BD%E7%94%A8private%E4%BF%AE%E9%A5%B0"><span class="toc-number">2.</span> <span class="toc-text">方法内部不能用private修饰</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8D%E5%90%8C"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. 变量的作用域不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. 访问修饰符的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JVM-%E5%86%85%E9%83%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.3.</span> <span class="toc-text">3. JVM 内部的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.0.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">锁的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.0.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">3.0.2.</span> <span class="toc-text">1. 作用域 &amp; 可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0-%E5%8E%9F%E7%90%86%E5%B7%AE%E5%BC%82%EF%BC%88%E5%85%B3%E9%94%AE%EF%BC%89"><span class="toc-number">3.0.3.</span> <span class="toc-text">2. 实现 &amp; 原理差异（关键）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8E%9F%E5%AD%90%E6%80%A7-%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%BF%9D%E9%9A%9C"><span class="toc-number">3.0.4.</span> <span class="toc-text">3. 原子性 &amp; 正确性保障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.0.5.</span> <span class="toc-text">4. 可靠性与故障模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-reentrancy%EF%BC%88%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7%EF%BC%89"><span class="toc-number">3.0.6.</span> <span class="toc-text">5. reentrancy（可重入性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%98%BB%E5%A1%9E-%E4%B8%AD%E6%96%AD-%E8%B6%85%E6%97%B6%E8%83%BD%E5%8A%9B"><span class="toc-number">3.0.7.</span> <span class="toc-text">6. 阻塞&#x2F;中断&#x2F;超时能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%80%A7%E8%83%BD-%E5%BB%B6%E8%BF%9F"><span class="toc-number">3.0.8.</span> <span class="toc-text">7. 性能 &amp; 延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7-%E8%B0%83%E8%AF%95"><span class="toc-number">3.0.9.</span> <span class="toc-text">8. 可观测性 &amp; 调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BB%A3%E7%A0%81%E5%A4%8D%E6%9D%82%E5%BA%A6-%E4%BD%BF%E7%94%A8%E9%A3%8E%E9%99%A9"><span class="toc-number">3.0.10.</span> <span class="toc-text">9. 代码复杂度 &amp; 使用风险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E8%AF%AD%E4%B9%89%E5%B7%AE%E5%BC%82"><span class="toc-number">3.0.11.</span> <span class="toc-text">10. 一致性与语义差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%9B%BF%E4%BB%A3-%E6%9B%B4%E5%BC%BA%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">3.0.12.</span> <span class="toc-text">11. 替代&#x2F;更强的方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%AE%9E%E6%88%98%E5%BB%BA%E8%AE%AE%EF%BC%88Checklist%EF%BC%89"><span class="toc-number">3.0.13.</span> <span class="toc-text">12. 实战建议（Checklist）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA%EF%BC%88%E5%BF%AB%E9%80%9F%E5%88%97%E4%B8%BE%EF%BC%89"><span class="toc-number">3.0.14.</span> <span class="toc-text">13. 常见误区（快速列举）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%B0%8F%E7%BB%93%EF%BC%88%E6%9C%80%E7%BB%88%E5%BB%BA%E8%AE%AE%EF%BC%89"><span class="toc-number">3.0.15.</span> <span class="toc-text">14. 小结（最终建议）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#private-RedisKeyConstants"><span class="toc-number">4.</span> <span class="toc-text">private RedisKeyConstants() {}</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">4.0.1.</span> <span class="toc-text">防止实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89"><span class="toc-number">4.0.2.</span> <span class="toc-text">防止被继承（可选）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">5.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.0.1.</span> <span class="toc-text">异常的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BC%A0%E6%92%AD"><span class="toc-number">5.0.2.</span> <span class="toc-text">异常的传播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">5.0.3.</span> <span class="toc-text">冒泡机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.0.4.</span> <span class="toc-text">异常在多线程中的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%9C%A8%E4%BD%A0%E6%B3%A8%E5%86%8C%E9%80%BB%E8%BE%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.0.5.</span> <span class="toc-text">异常在你注册逻辑中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">5.0.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">并发下的同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%EF%BC%9F"><span class="toc-number">6.0.1.</span> <span class="toc-text">一、核心思想：什么时候需要考虑？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E7%A7%8D%E2%80%9C%E9%99%B7%E9%98%B1%E2%80%9D"><span class="toc-number">6.0.2.</span> <span class="toc-text">二、问题的根源：并发操作的三种“陷阱”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.0.2.1.</span> <span class="toc-text">1. 竞态条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89"><span class="toc-number">6.0.2.2.</span> <span class="toc-text">2. 数据竞争</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">6.0.2.3.</span> <span class="toc-text">3. 缓存不一致性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%9E%E9%99%85%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">6.0.3.</span> <span class="toc-text">三、实际业务场景与解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF1%EF%BC%9A%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F-%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%EF%BC%88%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%89"><span class="toc-number">6.0.3.1.</span> <span class="toc-text">场景1：电商系统 - 库存扣减（竞态条件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF2%EF%BC%9A%E8%AE%A1%E6%95%B0%E5%99%A8-%E7%BB%9F%E8%AE%A1%EF%BC%88%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%EF%BC%89"><span class="toc-number">6.0.3.2.</span> <span class="toc-text">场景2：计数器 &amp; 统计（数据竞争）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF3%EF%BC%9A%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F-%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E4%B8%8E%E9%87%8D%E5%BB%BA%EF%BC%88%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E5%87%BB%E7%A9%BF%EF%BC%89"><span class="toc-number">6.0.3.3.</span> <span class="toc-text">场景3：缓存系统 - 缓存失效与重建（缓存雪崩&#x2F;击穿）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF4%EF%BC%9A%E9%87%91%E8%9E%8D%E7%B3%BB%E7%BB%9F-%E8%B4%A6%E6%88%B7%E8%BD%AC%E8%B4%A6%EF%BC%88%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%89"><span class="toc-number">6.0.3.4.</span> <span class="toc-text">场景4：金融系统 - 账户转账（竞态条件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF5%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%89"><span class="toc-number">6.0.3.5.</span> <span class="toc-text">场景5：单例模式（竞态条件）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7-%E6%9C%BA%E5%88%B6"><span class="toc-number">6.0.4.</span> <span class="toc-text">四、常用的同步工具&#x2F;机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">6.0.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CAS"><span class="toc-number">7.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81CAS-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.0.1.</span> <span class="toc-text">一、CAS 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81CAS-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">7.0.2.</span> <span class="toc-text">二、CAS 的核心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%80%E4%B8%AA%E7%94%9F%E5%8A%A8%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A%E4%B9%90%E8%A7%82%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="toc-number">7.0.3.</span> <span class="toc-text">三、一个生动的例子：乐观的版本控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81CAS-%E5%9C%A8-Java-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.0.4.</span> <span class="toc-text">四、CAS 在 Java 中的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5-AtomicInteger-%E7%9A%84-incrementAndGet-%E4%B8%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">7.0.4.1.</span> <span class="toc-text">以 AtomicInteger 的 incrementAndGet() 为例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81CAS-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">7.0.5.</span> <span class="toc-text">五、CAS 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">7.0.5.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">7.0.5.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81CAS-%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">7.0.6.</span> <span class="toc-text">六、CAS 的实际应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">7.0.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/7b25d017.html" title="redis"><img src="/img/5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis"/></a><div class="content"><a class="title" href="/posts/7b25d017.html" title="redis">redis</a><time datetime="2025-10-20T06:55:00.000Z" title="发表于 2025-10-20 14:55:00">2025-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/df28a7c5.html" title="博客优化"><img src="/img/5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="博客优化"/></a><div class="content"><a class="title" href="/posts/df28a7c5.html" title="博客优化">博客优化</a><time datetime="2025-10-20T06:55:00.000Z" title="发表于 2025-10-20 14:55:00">2025-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b50afe94.html" title="毛概主观题"><img src="/img/3.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="毛概主观题"/></a><div class="content"><a class="title" href="/posts/b50afe94.html" title="毛概主观题">毛概主观题</a><time datetime="2025-10-20T06:45:00.000Z" title="发表于 2025-10-20 14:45:00">2025-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eae30b66.html" title="毛概客观题"><img src="/img/2.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="毛概客观题"/></a><div class="content"><a class="title" href="/posts/eae30b66.html" title="毛概客观题">毛概客观题</a><time datetime="2025-10-20T06:45:00.000Z" title="发表于 2025-10-20 14:45:00">2025-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2d8be47d.html" title="登录注册优化"><img src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="登录注册优化"/></a><div class="content"><a class="title" href="/posts/2d8be47d.html" title="登录注册优化">登录注册优化</a><time datetime="2025-10-20T06:45:00.000Z" title="发表于 2025-10-20 14:45:00">2025-10-20</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 朝永</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>